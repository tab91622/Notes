[原题链接](https://github.com/lgwebdream/FE-Interview/issues/17)


## 什么是闭包
函数执行后**返回结果是一个内部函数**，并被外部变量所引用，如果**内部函数持有被执行函数作用域的变量**，即形成了闭包。

可以在内部函数访问到外部函数作用域。

使用闭包:
1. 可以读取函数中的变量

2. 可以将函数中的**变量存储在内存中，保护变量不被污染**。而正因闭包会把函数中的变量值存储在内存中，会对内存有消耗，所以不能滥用闭包，否则会影响网页性能，造成**内存泄漏**。当不需要使用闭包时，要及时释放内存，可将内层函数对象的**变量赋值为null**


## 闭包原理

函数执行分成两个阶段(**预编译阶段**和**执行阶段**)。

在预编译阶段，如果发现内部函数使用了外部函数的变量，则会在内存中创建一个“闭包”对象并保存对应变量值，如果已存在“闭包”，则只需要增加对应属性值即可。

执行完后，函数执行上下文会被销毁，函数对“闭包”对象的引用也会被销毁，但其内部函数还持用该“闭包”的引用，所以内部函数可以继续使用“外部函数”中的变量

利用了函数作用域链的特性，一个函数内部定义的函数会将包含外部函数的活动对象添加到它的作用域链中，函数执行完毕，其执行作用域链销毁，但因内部函数的作用域链仍然在引用这个活动对象，所以其活动对象不会被销毁，直到内部函数被销毁后才被销毁。


### 优点

* 可以从内部函数访问外部函数的作用域中的变量，且访问到的变量长期驻扎在内存中，可供之后使用, 避免变量污染全局

* 把变量存到独立的作用域，作为私有成员存在

### 缺点

* 对内存消耗有负面影响。因内部函数保存了对外部变量的引用，**导致无法被垃圾回收，增大内存使用量**，所以使用不当会导致内存泄漏

* 对处理速度具有负面影响。**闭包的层级决定了引用的外部变量在查找时经过的作用域链长度**

* 可能获取到意外的值(captured value)


## 应用场景

应用场景一： 典型应用是**模块封装**，在各模块规范出现之前，都是用这样的方式防止变量污染全局。

```js
var Yideng = (function () {
    // 这样声明为模块私有变量，外界无法直接访问
    var foo = 0;

    function Yideng() {}
    Yideng.prototype.bar = function bar() {
        return foo;
    };
    return Yideng;
}());
```

应用场景二： **在循环中创建闭包**，防止取到意外的值。

如下代码，无论哪个元素触发事件，都会弹出 3。因为函数执行后引用的 i 是同一个，而 i 在循环结束后就是 3

```js
for (var i = 0; i < 3; i++) {
    document.getElementById('id' + i).onfocus = function() {
      alert(i);
    };
}
//可用闭包解决
function makeCallback(num) {
  return function() {
    alert(num);
  };
}
for (var i = 0; i < 3; i++) {
    document.getElementById('id' + i).onfocus = makeCallback(i);
}
```